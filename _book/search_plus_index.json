{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 写本书的背景： 发觉一直在忙着业务需求开发，但是成长并不明显，所以就有了输出沉淀点东西的计划。刚好最近在公司一个新项目中全程使用 Typescript 开发，所以就希望能够在使用过后沉淀一下，也作为对自己学习 TS 的一种检查，从而反推自己再进一步深入理解这门语言。 开始阅读 "},"ji-chu/shen-me-shi-typescript.html":{"url":"ji-chu/shen-me-shi-typescript.html","title":"什么是TypeScript","keywords":"","body":"1. 什么是 Typescript? TypeScript 是一种由微软开发和维护的免费开源编程语言， 经过两年的开发于 2012 发布。创建它是为了允许进行可选的静态类型检查，这在开发大规模应用程序时特别有用。当初之所以开发 TypeScript 还是由于微软内部在使用 JavaScript开发内部项目是遇到缩放问题。 它是一个强类型的 JavaScript 超集，可编译为纯 JavaScript。 它是一种用于应用级 JavaScript 开发的语言。对于熟悉 c#、Java 和所有强类型语言的开发人员来说，TypeScript 非常容易学习和使用。 TypeScript 不是直接在浏览器上运行的。它需要一个编译器来编译和生成 JavaScript 文件。 TypeScript 是带有一些附加特性的 ES6 JavaScript 版本。 2. 什么是静态 Vs 动态类型？ 2.1 静态类型 如C、Java等都属于静态强类型语言，静态强类型是指在变量被定义的那一刻，它所存储的值的类型就已经确定了。 let name: string = '' name = 996 //报错 2.2 动态类型 动态类型语言又被称为弱类型语言，从字面意思上看这个刚刚和静态强类型意思相反了。。比较有代表性的就是JavaScript, 在 JavaScript 中我们定义一个变量，只要到了最终执行时才知道其存储的值的类型。并且还可以任意的给其赋不同类型的值，这在 JavaScript 这种动态类型语言中是被允许的。并且 JavaScript 也是足够智能可以知道/解释你要使用哪种变量类型。但是由于这样做会造成代码质量下降，因此才又被称为弱类型语言。 3. 什么是静态类型检查？TypeScript 如何实现它？ JavaScript 是动态类型的。 因此，用 JavaScript 编写的程序不知道变量的数据类型，直到在运行时为该变量分配值。 可以将变量重新分配或强制为其他类型的值，而不会出现问题或警告。 这可能会导致经常忽略的错误，尤其是在大型应用程序中。 另一方面，TypeScript 使用静态类型。它是JavaScript的超集，为用户提供了可选的静态类型和可靠的工具。 声明变量时，可以为其指定类型。 TypeScript 将在编译时检查类型，如果变量被赋予了不同类型的值，则会引发错误 —— TypeScript可以在不保存文件的情况下报告你代码中的问题 它通过类型检查代码来避免编写JavaScript时经常遇到的错误。。 但是，该错误不会阻止代码执行。 该代码仍将编译为纯 JavaScript 并正常运行。 这样，TypeScript 有点像对您的代码进行“拼写检查”。 它会在出现问题时通知您，但不会更改代码的运行方式。 静态类型在 TypeScript 中是可选的。可以为变量指定 any 类型，这将使 ​​ 其值成为任何类型。如果未指定任何类型，则默认情况下会将类型设置为 any 类型。 3.1 类型系统 通过引入可选的类型系统，TypeScript试图将静态类型的语言的优点带入动态的JavaScript世界。 这些好处包括： 使编写正确和可预测的代码更加容易，从而消除了常见错误，如错别字或对某种类型的值的错误假设。 与动态语言相反，类型错误是在编译时由类型检查器捕获的，而动态语言通常需要编写更多的单元测试来涵盖这些情况。 但是，这并不意味着用TypeScript编写的应用程序不需要单元测试。 这只是意味着它需要的数量更少。 有了有关类型的知识，IDE会提供很多功能，例如自动完成功能。 这使API更具可发现性，使开发人员不必始终检查API参考或完全了解所有API详细信息。 这通常会大大提高生产率。 它使执行自动和安全的代码重构（如重命名功能或变量）成为可能。 这种工具支持以及更轻松地浏览代码的能力（具有“转到定义”和“查找所有引用”之类的功能）使开发人员更容易使用大型代码库并将其保持在可维护的状态。 TypeScript引入的类型系统足够灵活，可以表示大多数广泛使用的JavaScript模式。 将该类型系统与主流的严格类型语言（如Java或C＃）中的那些区别的最大因素之一是，它实现了“结构子类型”，也称为“鸭子类型”。 有关该主题的更多详细信息，请参见此处。 其他值得注意的功能包括类型推断和泛型支持。 4. 为什么选择 TypeScript JavaScript远不是最佳设计的语言，它具有许多功能和怪异之处，因此很难构建大型应用程序： 一不小心就会在全局命名空间定义变量。 “==” 造成的强制类型转换。 this指向问题； 以上三点在 JavaScript 代码中随处可见，但是这些行为可能会使代码变得混乱且容易出错。 而且，JavaScript是一种面向对象的语言，它不具有基于类的继承，因此选择了一种典型的继承。 虽然原型继承本身并不是一件坏事，但是对于那些来自基于类的语言背景（例如Java或C＃）的开发人员来说，继承就不那么容易了。 这使弄清楚如何组织层次结构或隐藏某些对象成员（如私有字段和方法）变得有些困难。 就是说，对于Web应用程序，客户端开发JavaScript是唯一的选择。它是所有浏览器普遍支持的唯一客户端语言。 随着越来越多地将Web应用程序视为一种分发模型（distribution model），该分发模型非常接近兑现“编写一次，随处运行（write once, run everywhere）”的承诺，现代客户端Web应用程序的大小和复杂性明显超过了JavaScript的功能。 （至少在不久的将来）用更适合的语言替换JavaScript的可能性很小，因为要说服所有浏览器供应商普遍同意并采用一种新的语言是一个巨大的挑战。 这种认识促使不同的小组开发解决方案，这些解决方案可以使用JavaScript代码编译现有或全新的语言，而不是单独使用。 其中包括： Google’s GWT and Dart) CoffeeScript Microsoft’s TypeScript 注意：在某种程度上，这些解决方案 将JavaScript视为Web的汇编语言。 TypeScript被描述为JavaScript的严格超集，它添加了可选的静态类型和符合 ES6 标准建议的基于类的面向对象的编程。 它被编译为惯用的JavaScript，不需要任何类型的运行时库来支持它。这段话的意思体现了两个TypeScript设计目标，即： 静态识别可能是错误的构造 为较大的代码段提供结构化机制 4.1 优点 Early Detection of Errors 及早发现错误 Improves Code Readability 提高代码可读性 Promotes Dependable Refactoring 促进可靠的重构 Improved IDE Support 改进的 IDE 支持 Easy Code Analysis 简易代码分析 4.2 缺点 任何事物都是有两面性的，我认为 TypeScript 的弊端在于： 有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念 短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本 集成到构建流程需要一些工作量 可能和一些库结合的不是很完美 对于一直使用动态类型语言背景的人来说， 需要在代码中的所有地方使用类型注释，这有时可能很麻烦。 有时在使用第三方库时需要自己定义声明文件（.d.ts） 或遇到第三方模块定义的类型声明文件存在质量问题，这都会在一定程度上 block 开发的进度。 由于任何JavaScript代码都是有效的TypeScript代码，因此TypeScript无法解决一些基本的JavaScript问题。另一方面，它可能会产生一种幻想：它会通过给出安全性幻想而引起更多的混乱。 扩。 大家可以根据自己团队和项目的情况判断是否需要使用 TypeScript。 5. TypeScript 和 JavaScript 有什么不同？ JavaScript TypeScript 1 由网景公司在 1995 年开发的。 由微软于2012发布 2 文件以”.js”后缀 文件是以”.ts”后缀 3 不支持 ES6 支持 ES6 4 不支持强类型或静态类型 支持强类型或静态类型特性 5 它只是一种脚本语言 它支持面向对象的编程概念，如类、接口、继承、泛型等。 6 没有可选的参数特性。 有可选的参数特性。 7 它是解释语言，这就是为什么它在运行时突出显示错误。 它编译代码并在开发期间突出显示错误。 8 不支持模块。 支持模块。 9 在这里，number 和 string 是对象。 在这里，number 和 string 是接口。 10 JavaScript 不支持泛型。 TypeScript 支持泛型。 "},"ji-chu/ben-di-kai-fa-huan-jing-da-jian.html":{"url":"ji-chu/ben-di-kai-fa-huan-jing-da-jian.html","title":"本地开发环境搭建","keywords":"","body":"1. 配置ts编译环境 目标：将指定文件夹下的ts代码转换输出到另一个指定的文件夹下面。 tsconfig.json 文件： { \"compilerOptions\": { \"target\": \"es5\", // \"module\": \"commonjs'\", \"outDir\": \"./js/\", \"rootDir\": \"./tscript/\", \"esModuleInterop\": true } } 2. 本地运行 ts 环境配置： 目标：vscode中能够直接执行ts代码。 // 全局安装ts-node npm i -g ts-node // 右键 执行“Run Code\" "},"ji-chu-1/shen-me-shi-lei-xing-jian-cha.html":{"url":"ji-chu-1/shen-me-shi-lei-xing-jian-cha.html","title":"什么是类型检查","keywords":"","body":"什么是类型检查 "},"ji-chu-1/lei-xing.html":{"url":"ji-chu-1/lei-xing.html","title":"类型","keywords":"","body":"类型 Javascript中数据类型分为两种: 第一种 是基本数据类型 包括number、string、boollen、null、undefined以及es6 的symbol。 第二种 是引用类型，包括数组、对象、函数； 基本数据类型 基本数据类型也被称为原始数据类型（Primitive data types）。 布尔值 let loading: boolean = false 注意，使用构造函数 Boolean 创造的对象不是布尔值： let createdByNewBoolean: boolean = new Boolean(1); // Type 'Boolean' is not assignable to type 'boolean'. // 'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible. 事实上 new Boolean() 返回的是一个 Boolean 对象： let createdByNewBoolean: Boolean = new Boolean(1); 直接调用 Boolean 也可以返回一个 boolean 类型： let createdByBoolean: boolean = Boolean(1); 在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。 数值 在 TypeScript 中使用 number 定义数值类型： let decLiteral: number = 6; let hexLiteral: number = 0xf00d; // ES6 中的二进制表示法 let binaryLiteral: number = 0b1010; // ES6 中的八进制表示法 let octalLiteral: number = 0o744; let notANumber: number = NaN; let infinityNumber: number = Infinity; // >>>>>>>>>>>> 编译结果为 字符串 使用 string 定义字符串类型： let myName: string = 'Tom'; let myAge: number = 25; // 模板字符串 let sentence: string = `Hello, my name is ${myName}. I'll be ${myAge + 1} years old next month.`; // >>>>>>>>>>>>>> 编译结果： 空值 JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数： function alertName(): void { alert('My name is Tom'); } let unusable: void = undefined; // 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null Null 和 Undefined 在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型： let u: undefined = undefined; let n: null = null; 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量： // 这样不会报错 let num: number = undefined; // 这样也不会报错 let u: undefined; let num: number = u; // 而 void 类型的变量不能赋值给 number 类型的变量： let u: void; let num: number = u; // Type 'void' is not assignable to type 'number'. 引用类型 引用类型 也被称为对象类型（Object types）。 对象类型 —— 接口 数组的类型 函数的类型 任意类型 —— any 任意值（Any）用来表示允许赋值为任意类型。 // 在任意值上访问任何属性都是允许的 let anyThing: any = 'hello'; console.log(anyThing.myName); console.log(anyThing.myName.firstName); // 也允许调用任何方法： let anyThing: any = 'Tom'; anyThing.setName('Jerry'); anyThing.setName('Jerry').sayHello(); anyThing.myName.setFirstName('Cat'); 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。 注意：变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型： let something; something = 'seven'; something = 7; something.setName('Tom'); // 等价于 let something: any; something = 'seven'; something = 7; something.setName('Tom'); "},"ji-chu-1/namespace.html":{"url":"ji-chu-1/namespace.html","title":"命名空间","keywords":"","body":"在 JavaScript 使用命名空间时， 这有一个常用的、方便的语法： (function(something) { something.foo = 123; })(something || (something = {})); something || (something = {}) 允许匿名函数 function (something) {} 向现有对象添加内容，或者创建一个新对象，然后向该对象添加内容。这意味着你可以拥有两个由某些边界拆成的块。 (function(something) { something.foo = 123; })(something || (something = {})); console.log(something); // { foo: 123 } (function(something) { something.bar = 456; })(something || (something = {})); console.log(something); // { foo: 123, bar: 456 } 在确保创建的变量不会泄漏至全局命名空间时，这种方式在 JavaScript 中很常见。当基于文件模块使用时，你无须担心这点，但是该模式仍然适用于一组函数的逻辑分组。因此 TypeScript 提供了 namespace 关键字来描述这种分组，如下所示。 namespace Utility { export function log(msg) { console.log(msg); } export function error(msg) { console.log(msg); } } // usage Utility.log('Call me'); Utility.error('maybe'); namespace 关键字编译后的 JavaScript 代码，与我们早些时候看到的 JavaScript 代码一样。 (function (Utility) { // 添加属性至 Utility })(Utility || Utility = {}); 值得注意的一点是，命名空间是支持嵌套的。因此，你可以做一些类似于在 Utility 命名空间下嵌套一个命名空间 Messaging 的事情。 对于大多数项目，我们建议使用外部模块和命名空间，来快速演示和移植旧的 JavaScript 代码。 "},"ji-chu-1/interface.html":{"url":"ji-chu-1/interface.html","title":"接口","keywords":"","body":" 1、接口运行时的影响为 0。在 TypeScript 接口中有很多方式来声明变量的结构; 2、接口让我们可以更优化的定义变量结构； 3、接口旨在声明 JavaScript 中可能存在的任意结构。 下面两个是等效的声明, 示例 A 使用了内联注解，示例 B 使用的是接口形式： // 示例 A declare const myPoint: { x: number; y: number }; // 示例 B interface Point { x: number; y: number; } declare const myPoint: Point; 示例 B 的好处在于，如果有人创建了一个基于 myPoint 的库来添加新成员, 那么他可以轻松将此成员添加到 myPoint 的现有声明中: // Lib a.d.ts interface Point { x: number, y: number } declare const myPoint: Point // Lib b.d.ts interface Point { z: number } // Your code myPoint.z // Allowed! TypeScript 接口是开放式的，这是 TypeScript 的一个重要原则，它允许你使用接口来模仿 JavaScript 的可扩展性。 1. 类可以实现接口 如果你希望在类中使用必须要被遵循的接口（类）或别人定义的对象结构，可以使用 implements 关键字来确保其兼容性： interface Point { x: number; y: number; } class MyPoint implements Point { x: number; y: number; // Same as Point } 基本上，在 implements（实现） 存在的情况下，该外部 Point 接口的任何更改都将导致代码库中的编译错误，因此可以轻松地使其保持同步： interface Point { x: number; y: number; z: number; // New member } class MyPoint implements Point { // ERROR : missing member `z` x: number; y: number; } 注意，implements 限制了类实例的结构，如下所示: let foo: Point = new MyPoint(); 但像 foo: Point = MyPoint 这样的代码，与其并不是一回事。 2. 注意: 并非每个接口都是很容易实现的 接口旨在声明 JavaScript 中可能存在的任意结构。 思考一下下面这个例子，可以使用 new 调用某些内容： interface Crazy { new (): { hello: number; }; } 你可能会有下面这样的代码： class CrazyClass implements Crazy { constructor() { return { hello: 123 }; } } // Because const crazy = new CrazyClass(); // crazy would be { hello:123 } 对的，你可以使用接口声明一些奇奇怪怪的 js 代码，甚至TS既不会报错也能正常运行。但是非常不建议你这样做！ "},"ji-chu-1/enum.html":{"url":"ji-chu-1/enum.html","title":"枚举","keywords":"","body":"什么是枚举 枚举是组织收集有关联变量的一种方式。 释意： 枚举也可以称作列举或一一列举，用于定义静态常量。 以我的理解答：枚举是我们自己定义的一个集合，比如说我们数学里面所学的集合 A={1、2、3}, 当我们要使用A这个集合的时候，我们只能够使用集合A里面的1、2、3这三个元素，不是 A 里的元素就不可以使用。 同样，枚举和这个集合是类似的，当定义了一个枚举类型的时候声明它里面有几个元素，在使用这个枚举的时候只能够使用它有的元素，没有的元素是无法使用，否则就会报错！ 枚举还有一个特点，就是可以代表数值，比如说第一个定义的元素对应的值为0，每个枚举元素从0开始，逐一增加。此时，这个数值也代表他们本身，相当于每一个元素有两个名字。 使用场景： 我们要从另一个函数得到一个值，但是这个值只能够在一个范围内的，此时我们就可以使用枚举来定义这个范围。限制另外一个函数能够传递进来的值，只能够是枚举类型里面的元素。 "},"ji-chu-1/tsconfig-json.html":{"url":"ji-chu-1/tsconfig-json.html","title":"tsconfig.json","keywords":"","body":"1. 简介 通常放置在ts项目根目录下，指定了用来编译这个项目的根文件和编译选项。 2. tsconfig.json 文件结构： { compileOnSave: true, // 告诉IDE在保存文件时根据tsconfig.json重新生成文件 compileOptions: { // 编译选项 outDir: {} // 指定编译生成文件存放位置 rootDir: \"./tscript/\", // 指定需要编译的ts源码位置 // .... }, files: [ ... ], // 指定哪些文件包含进来 include: [ .... ], // 指定哪些文件包含进来 exclude: [ ... ] // 指定哪些文件不包含进来 } 实例： { \"compilerOptions\": { \"allowJs\": false, // 是否允许编译javascript文件 \"target\": \"esnext\", // 指定ECMAScript目标版本 \"ES3\"（默认）, \"ESNext\"最新的生成目标列表为 \"module\": \"esnext\", // 指定生成哪个模块系统代码, \"noImplicitAny\": false, // 在表达式和声明上有隐含的 any类型时报错。 \"strict\": true, // 启用所有严格类型检查选项。 \"jsx\": \"preserve\", // 在 .tsx文件里支持JSX： \"React\"或 \"Preserve\" \"importHelpers\": true, // 从 tslib 导入辅助工具函数（比如 __extends， __rest等） \"moduleResolution\": \"node\", // 决定如何处理模块 \"experimentalDecorators\": true, // 启用实验性的es装饰器 \"esModuleInterop\": true, // 允许从没有设置默认导出的模块中默认导入。这并不影响代码的输出，仅为了类型检查。 \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。这并不影响代码的输出，仅为了类型检查。 \"sourceMap\": true, // 生成相应的 .map文件。 \"baseUrl\": \".\", // 解析非相对模块名的基准目录。 \"types\": [\"webpack-env\"], // 要包含的类型声明文件名列表。 \"paths\": { // 模块名到基于 baseUrl的路径映射的列表。 \"@/*\": [\"src/*\"] }, \"lib\": [\"esnext\", \"dom\", \"dom.iterable\", \"scripthost\"] // 编译过程中需要引入的库文件的列表。 }, \"files\": [\"src/index.d.ts\"], \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"tests/**/*.ts\", \"tests/**/*.tsx\" ], \"exclude\": [\"node_modules\"] } 3. 属性解析 3.1 compileOnSave 可以让IDE在保存文件的时候根据tsconfig.json重新生成文件。想要使用这个特性需要你是VS 2015， TS1.8.4以上 并且安装了atom-typescript插件的前提下才可以。 3.2 extends tsconfig.json文件可以利用extends属性从另一个配置文件里继承配置。extends的值是指向另一个要继承文件的路径。 “原配置文件” 里的配置会先被加载，之后才会去加载 “被集成配置文件” 里的配置， “被继承配置文件” 里的配置会对 “原配置文件” 里的配置重写。 extends属性的值 是一个相对路径。 3.3 files files 指定的是一个包含相对路径或绝对路径的列表。 3.4 includes includes 也可以指定哪些文件被编译器包含，功能类似 files。但是两者的区别在于： files 列表里的文件已经会被编译器包含。 includes 列表里的文件未必会被编译器包含，因为可以被 exclude 忽略！ 3.5exclude exclude 指定哪些文件不会被编译器包含。 "},"ji-chu-1/define-file.html":{"url":"ji-chu-1/define-file.html","title":"声明文件","keywords":"","body":"1. 什么是声明文件 当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。 通常在实际项目开发中我们不可避免的会使用其他一些第三方JavaScript库，但又不是所有第三方库都有定义类型声明，如果第三方库没有定义声明文件，是不能直接使用该库的，通常TS都会报错。为了解决这个问题，需要将这些库里的函数和方法体去掉后只保留导出类型声明，而产生了一个描述 JavaScript 库和模块信息的声明文件。通过引用这个声明文件，就可以借用 TypeScript 的各种特性来使用库文件了。 所以，对于声明文件你需要知道的有： 声明文件只做类型定义。 声明文件以 .d.ts 为后缀。 引入声明文件语法格式：/// declare 定义的类型只会用于编译时的检查，编译结果中会被删除。 声明文件不包含实现，它只是类型声明。 在深入声明文件之前，我们先来看看什么是声明语句。 1.1 什么是声明语句？ 假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 标签引入 jQuery，然后就可以使用全局变量 $或 jQuery 了。 我们通常这样获取一个 id 是 foo 的元素： $('#foo'); // or jQuery('#foo'); 但是在 ts 中，编译器并不知道 $ 或 jQuery 是什么东西： jQuery('#foo'); // ERROR: Cannot find name 'jQuery'. 这时，我们需要使用 declare var 来定义它的类型： declare var jQuery: (selector: string) => any; jQuery('#foo'); 上例中，declare var 并没有真的定义一个变量，只是定义了全局变量 jQuery 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。 它编译结果是： jQuery('#foo'); 除了 declare var 之外，还有其他很多种声明语句，将会在后面详细介绍。 OK， 让我们再回到声明文件上来。 1.2 什么是声明文件 通常我们会把声明语句放到一个单独的文件（jQuery.d.ts）中，这就是声明文件3： // src/jQuery.d.ts declare var jQuery: (selector: string) => any; // src/index.ts jQuery('#foo'); 声明文件必需以 .d.ts 为后缀。 一般来说，ts 会解析项目中所有的 .ts 文件，当然也包含以 .d.ts 结尾的文件。所以当我们将 jQuery.d.ts 放到项目中时，其他所有 .ts 文件就都可以获得 jQuery 的类型定义了。 /path/to/project ├── src | ├── index.ts | └── jQuery.d.ts └── tsconfig.json 假如仍然无法解析，那么可以检查下 tsconfig.json 中的 files、include 和 exclude 配置，确保其包含了 jQuery.d.ts 文件。 这里只演示了全局变量这种模式的声明文件，假如是通过模块导入的方式使用第三方库的话，那么引入声明文件又是另一种方式了，将会在后面详细介绍。 1.3 第三方声明文件§ 当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：jQuery in DefinitelyTyped。 我们可以直接下载下来使用，但是更推荐的是使用 @types 统一管理第三方库的声明文件。 @types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例： npm install @types/jquery --save-dev 可以在这个页面搜索你需要的声明文件。 2、如何写 TS 声明文件 2.1 全局变量 全局变量的声明文件主要有以下几种语法： declare var 声明全局变量 declare function 声明全局方法 declare class 声明全局类 declare enum 声明全局枚举类型 declare namespace 声明（含有子属性的）全局对象 interface 和 type 声明全局类型 3、参考 TypeScript 声明文件 如何编写 Typescript 声明文件 TypeScript 中的声明文件 "},"Advance/how-ts-work.html":{"url":"Advance/how-ts-work.html","title":"TypeScript 是怎样工作的","keywords":"","body":"TypeScript 是怎样工作的 翻译自： https://2ality.com/2020/04/typescript-workflows.html 此外，在不违背原作者本意前提下，为了更直观的表达，部分内容将采用意译，而非直译。 这篇博客文章概述了 TypeScript 的工作原理：典型的TypeScript项目的结构是什么？什么被编译以及如何编译？我们如何使用IDE编写TypeScript？ 1. TypeScript项目的结构 这是 TypeScript 项目的一种可能的文件结构： typescript-project/ dist/ ts/ src/ main.ts util.ts test/ util_test.ts tsconfig.json 说明： 目录 ts/ 包含 TypeScript 文件： 子目录 ts/src/ 包含实际代码。 子目录 ts/test/ 包含代码测试。 目录 dist/ 是编译器的输出位置。 TypeScript 编译器将诸如 ts/src/main.ts 之类的 TypeScript 文件编译为 JavaScript 文件 dist/src/main.js （可能还有其他文件）。 tsconfig.json 用于配置 TypeScript 编译器。 1.1 tsconfig.json tsconfig.json 的内容如下： { \"compilerOptions\": { \"rootDir\": \"ts\", \"outDir\": \"dist\", \"module\": \"commonjs\", ··· } } 我们已指定： TS 代码的根目录是 ts/。 TS 编译器保存其输出的目录为 dist/。 输出文件的模块格式为 CommonJS。 2. 通过集成 IDE 编写 TypeScript VSCode 是用于编写 TS 代码的最受欢迎的 IDE 之一。为了更好地使用它，我们需要了解 TS 源代码是以两种独立的方式处理的： 检查打开的编辑器是否存在错误：这是通过所谓的 language server 完成的。它们是与编辑器无关的方法，可为编辑器提供与语言相关的服务（检测错误、重构、自动完成等）。编辑器（例如IDE）通过特殊协议（JSON-RPC，即基于JSON的远程过程调用）与语言服务器进行通信。这样一来，几乎可以用任何编程语言编写此类服务器。 要记住：language server 仅列出当前打开的编辑器的错误，且不编译 TypeScript，而是仅仅静态分析它。 Building（将 TypeScript 文件编译为 JavaScript 文件）：在这里，我们有两个选择。 我们可以通过命令行运行构建工具。例如，TypeScript 编译器 tsc 有 --watch 模式，该模式可以监视输入文件，并在更改文件时将其编译为输出文件。这样，每当我们在 IDE 中保存 TypeScript 文件时，都会立即获得相应的输出文件。 我们可以在 VsCode 中运行 tsc。为此，必须将其安装在我们当前正在开发的项目内部或进行全局安装（通过 Node.js 包管理器 npm）。 通过构建，我们可以获得完整的错误列表。有关在 VsCode 中编译 TypeScript 的更多信息，请参见该 IDE 的官方文档。 3. TypeScript 编译器生成的其他文件 给定 TS 文件 main.ts，TS 编译器可以产生几种工件。最常见的是： JavaScript文件：main.js 声明文件：main.d.ts（包含类型信息） 源码映射文件：main.js.map TypeScript 通常不是通过 .ts 文件提供的，而是通过 .js 文件和 .d.ts 文件提供： JavaScript 代码包含实际的功能，可以通过普通 JavaScript 使用。 声明文件可帮助编程编辑者实现自动补全和类似的服务。此信息使普通 JavaScript 可以通过 TypeScript 使用。但是如果使用纯 JavaScript，我们甚至会从中受益，因为它可以提供更好的自动完成以及更多功能。 源码映射为 main.js 中输出代码的每一部分指定在 main.ts 中的输入代码的哪一部分生成了它。除其他外，此信息使运行时环境能够执行 JS 代码，同时在错误信息中显示 TS 代码的行号。 4. 为了使用 TS 中的 npm 包，我们需要类型信息 npm 注册表是一个巨大的 JavaScript 代码库。如果要使用 TypeScript 中的 JavaScript包，则需要类型信息： 软件包本身可能包含 .d.ts 文件，甚至完整的 TypeScript 代码。 如果没有，我们仍然可以使用它：DefinitelyTyped 是人们为普通 JavaScript 包编写的声明文件的库。 DefinitelyTyped 的声明文件位于 @types 命名空间中。所以如果我们需要像 lodash 这样的包的声明文件，则必须安装 @types/lodash 包。 5. 将 TS 编译器用于纯 Js 文件 TypeScript 编译器还可以处理普通的 JavaScript 文件： 使用选项 --allowJs，TypeScript 编译器将输入目录中的 JavaScript 文件复制到输出目录中。好处：当从 JavaScript 迁移到 TypeScript 时，我们可以先使 JavaScript 和 TypeScript 文件混合存在，然后再慢慢把更多 JavaScript 文件转换为 TypeScript 。 使用选项 --checkJs，编译器还会对 JavaScript 文件进行类型检查（必须启用 --allowJs 才能使该选项起作用）。鉴于可用信息有限，它会尽其所能。 如果 JavaScript 文件包含注释 //@ts-nocheck，则不会对其进行类型检查。 如果没有 --checkJs，注释 //@ts-check 可用于对单个 JavaScript 文件进行类型检查。 TypeScript 编译器使用通过 JSDoc 注释指定的静态类型信息（请参见下面的例子）。如果可以的话，我们可以完全静态类型化纯 JavaScript 文件，甚至可以派生它们的声明文件。 使用选项 --noEmit，编译器不会产生任何输出，它只会对文件进行类型检查。 This is an example of a JSDoc comment that provides static type information for a function add(): 这是一个 JSDoc 注释的例子，它为函数 add() 提供静态类型信息： /** * @param {number} x - A number param. * @param {number} y - A number param. * @returns {number} This is the result */ function add(x, y) { return x + y; } "},"Advance/ts-compile-principle.html":{"url":"Advance/ts-compile-principle.html","title":"TypeScript 编译原理","keywords":"","body":"首先，TypeScript编译器部分的实现源码在其 github仓库 的 src/compiler 目录下。 分为以下几个关键部分: Scanner 扫描器（scanner.ts） Parser 解析器（parser.ts） Binder 绑定器（binder.ts） Checker 检查器（checker.ts） Emitter 发射器（emitter.ts） 概括 上图简单说明 TypeScript 编译器如何将上述几个关键部分组合在一起： 源码 ～ scanner(扫描器) ～ token数据流 ～ parser(解析器) -> AST(抽象语法树) AST(抽象语法树) ～ binder(绑定器) -> symbols(符号) AST(抽象语法树) + symbols ~ checker(检查器) -> 类型检查功能 AST(抽象语法树) + checker(检查器) ～ emitter(发射器) -> js代码 流程 1： 源码 => AST 源码 ～ scanner(扫描器) ～ token数据流 ～ parser(解析器) -> AST(抽象语法树) 在内部，由 parser解析器控制scanner扫描器将源码转化为抽象语法树（AST）。流程如下： 若以常见的AST生成过程类比，可简单类比上述的 扫描器阶段 可对应为 词法分析过程，解析器阶段可对应为语法分析过程。 有关AST抽象语法树 可参考 AST抽象语法树。 1.1 解析器对扫描器的使用 通过 parseSourceFile 设置初始状态并将工作交给 parseSourceFileWorker 函数。 1.1.1 parseSourceFile // 解析源码文件 export function parseSourceFile(fileName: string, sourceText: string, languageVersion: ScriptTarget, syntaxCursor: IncrementalParser.SyntaxCursor | undefined, setParentNodes = false, scriptKind?: ScriptKind): SourceFile { scriptKind = ensureScriptKind(fileName, scriptKind); //初始化状态 if (scriptKind === ScriptKind.JSON) { const result = parseJsonText(fileName, sourceText, languageVersion, syntaxCursor, setParentNodes); convertToObjectWorker(result, result.parseDiagnostics, /*returnValue*/ false, /*knownRootOptions*/ undefined, /*jsonConversionNotifier*/ undefined); result.referencedFiles = emptyArray; result.typeReferenceDirectives = emptyArray; result.libReferenceDirectives = emptyArray; result.amdDependencies = emptyArray; result.hasNoDefaultLib = false; result.pragmas = emptyMap; return result; } //专备好扫描器状态 initializeState(sourceText, languageVersion, syntaxCursor, scriptKind); //将工作交给 parseSourceFileWorker const result = parseSourceFileWorker(fileName, languageVersion, setParentNodes, scriptKind); clearState(); return result; } 1.1.2 parseSourceFileWorker 该函数先创建一个 SourceFile AST 节点，然后从 parseStatement 函数开始解析源代码。一旦返回结果，就用额外信息（例如 nodeCount, identifierCount等） 完善 SourceFile 节点。 function parseSourceFileWorker(fileName: string, languageVersion: ScriptTarget, setParentNodes: boolean, scriptKind: ScriptKind): SourceFile { const isDeclarationFile = isDeclarationFileName(fileName); if (isDeclarationFile) { contextFlags |= NodeFlags.Ambient; } // 先创造一个 SourceFile AST 节点 sourceFile = createSourceFile(fileName, languageVersion, scriptKind, isDeclarationFile); sourceFile.flags = contextFlags; // Prime the scanner. nextToken(); // A member of ReadonlyArray isn't assignable to a member of T[] (and prevents a direct cast) - but this is where we set up those members so they can be readonly in the future processCommentPragmas(sourceFile as {} as PragmaContext, sourceText); processPragmasIntoFields(sourceFile as {} as PragmaContext, reportPragmaDiagnostic); // 调用 parseStatement 函数解析源码 sourceFile.statements = parseList(ParsingContext.SourceElements, parseStatement); Debug.assert(token() === SyntaxKind.EndOfFileToken); // 至871行 均为完善 sourcefile AST 节点 sourceFile.endOfFileToken = addJSDocComment(parseTokenNode()); setExternalModuleIndicator(sourceFile); sourceFile.nodeCount = nodeCount; sourceFile.identifierCount = identifierCount; sourceFile.identifiers = identifiers; sourceFile.parseDiagnostics = parseDiagnostics; if (setParentNodes) { fixupParentReferences(sourceFile); } return sourceFile; function reportPragmaDiagnostic(pos: number, end: number, diagnostic: DiagnosticMessage) { parseDiagnostics.push(createFileDiagnostic(sourceFile, pos, end, diagnostic)); } } 1.1.3 节点创建：parseStatement/parseXXXX等 其中 parseStatement 函数，它根据扫描器返回的当前 token 来切换（调用相应的 parseXXX 函数），生成 AST 节点。 function parseStatement(): Statement { // 此处 token 为 scanner扫描器 返回的 当前token流, SyntaxKind为AST的常量枚举类型，根据不同的类型创建不同的节点 switch (token()) { // 类型为 SemicolonToken，调用parseEmptyStatement case SyntaxKind.SemicolonToken: return parseEmptyStatement(); case SyntaxKind.OpenBraceToken: return parseBlock(/*ignoreMissingOpenBrace*/ false); case SyntaxKind.VarKeyword: return parseVariableStatement(createNodeWithJSDoc(SyntaxKind.VariableDeclaration)); case SyntaxKind.LetKeyword: if (isLetDeclaration()) { return parseVariableStatement(createNodeWithJSDoc(SyntaxKind.VariableDeclaration)); } break; case SyntaxKind.FunctionKeyword: return parseFunctionDeclaration(createNodeWithJSDoc(SyntaxKind.FunctionDeclaration)); case SyntaxKind.ClassKeyword: return parseClassDeclaration(createNodeWithJSDoc(SyntaxKind.ClassDeclaration)); case SyntaxKind.IfKeyword: return parseIfStatement(); case SyntaxKind.DoKeyword: return parseDoStatement(); case SyntaxKind.WhileKeyword: return parseWhileStatement(); case SyntaxKind.ForKeyword: return parseForOrForInOrForOfStatement(); case SyntaxKind.ContinueKeyword: return parseBreakOrContinueStatement(SyntaxKind.ContinueStatement); case SyntaxKind.BreakKeyword: return parseBreakOrContinueStatement(SyntaxKind.BreakStatement); case SyntaxKind.ReturnKeyword: return parseReturnStatement(); case SyntaxKind.WithKeyword: return parseWithStatement(); case SyntaxKind.SwitchKeyword: return parseSwitchStatement(); case SyntaxKind.ThrowKeyword: return parseThrowStatement(); case SyntaxKind.TryKeyword: // Include 'catch' and 'finally' for error recovery. case SyntaxKind.CatchKeyword: case SyntaxKind.FinallyKeyword: return parseTryStatement(); case SyntaxKind.DebuggerKeyword: return parseDebuggerStatement(); case SyntaxKind.AtToken: return parseDeclaration(); case SyntaxKind.AsyncKeyword: case SyntaxKind.InterfaceKeyword: case SyntaxKind.TypeKeyword: case SyntaxKind.ModuleKeyword: case SyntaxKind.NamespaceKeyword: case SyntaxKind.DeclareKeyword: case SyntaxKind.ConstKeyword: case SyntaxKind.EnumKeyword: case SyntaxKind.ExportKeyword: case SyntaxKind.ImportKeyword: case SyntaxKind.PrivateKeyword: case SyntaxKind.ProtectedKeyword: case SyntaxKind.PublicKeyword: case SyntaxKind.AbstractKeyword: case SyntaxKind.StaticKeyword: case SyntaxKind.ReadonlyKeyword: case SyntaxKind.GlobalKeyword: if (isStartOfDeclaration()) { return parseDeclaration(); } break; } return parseExpressionOrLabeledStatement(); } 例如：如果当前 token 是一个 SemicolonToken（分号标记），就会调用 paserEmptyStatement 为空语句创建一个 AST 节点。 1.1.4 paserEmptyStatement/parseIfStatement等等 function parseEmptyStatement(): Statement { const node = createNode(SyntaxKind.EmptyStatement); parseExpected(SyntaxKind.SemicolonToken); return finishNode(node); } function parseIfStatement(): IfStatement { const node = createNode(SyntaxKind.IfStatement); parseExpected(SyntaxKind.IfKeyword); parseExpected(SyntaxKind.OpenParenToken); node.expression = allowInAnd(parseExpression); parseExpected(SyntaxKind.CloseParenToken); node.thenStatement = parseStatement(); node.elseStatement = parseOptional(SyntaxKind.ElseKeyword) ? parseStatement() : undefined; return finishNode(node); } 观察上述 parseXXXX 等，会发现其中存在三个关键函数createNode，parseExpected，finishNode 1.1.4.1createNode function createNode(kind: SyntaxKind, pos?: number): Node { nodeCount++; // 获取初始位置（可调用扫描器scanner的startPos，'Start position of whitespace before current token') const p = pos! >= 0 ? pos! : scanner.getStartPos(); // 返回节点类型 return isNodeKind(kind) || kind === SyntaxKind.Unknown ? new NodeConstructor(kind, p, p) : kind === SyntaxKind.Identifier ? new IdentifierConstructor(kind, p, p) : new TokenConstructor(kind, p, p); } 1.1.4.2 parseExpected function parseExpected(kind: SyntaxKind, diagnosticMessage?: DiagnosticMessage, shouldAdvance = true): boolean { // 检查当前token是否与当前传入的kind是否一致 if (token() === kind) { if (shouldAdvance) { nextToken(); } return true; } // 如token与kind不一致，则根据是否传入diagnosticMessage（诊断信息），回传错误 if (diagnosticMessage) { parseErrorAtCurrentToken(diagnosticMessage); } else { parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(kind)); } return false; } 1.1.4.3 finishNode function finishNode(node: T, end?: number): T { // 获取结束位置 node.end = end === undefined ? scanner.getStartPos() : end; // 添加标记 if (contextFlags) { node.flags |= contextFlags; } //判断是否出现错误，若出现错误就不会标记任何后续节点。 if (parseErrorBeforeNextFinishedNode) { parseErrorBeforeNextFinishedNode = false; node.flags |= NodeFlags.ThisNodeHasError; } return node; } 至此， AST构建完成。 "}}